# Kotlin compiler structure

Kotlin compiler is built from two major parts, usually referred to as **frontend** and **backend**.

## Frontend

Frontend is the part where compiler takes the code you have written and tries to comprehend what it could mean. Most of the syntax/type-checking is done here. After frontend has finished its execution, it produces a complete structure describing the code in a form of IR (intermediate representation). (note: [[compiler-rewrite]]).

Frontend stages are:

### Lexing

Lexer annotates the original code (string) with a sequence of tokens. These tokens attach meaning to particular substrings (keywords, operators, etc).

<table>
<tr>
  <th>Example input</th>
  <th>Example output</th>
</tr>
<tr>
<td>

```kotlin
class Test {  
    fun example() {  }
}
```

</td>
<td>

```
CLASS_KEYWORD WHITE_SPACE IDENTIFIER("Test") WHITE_SPACE LBRACE
     FUN_KEYWORD IDENTIFIER("example") LPAR RPAR LBRACE WHITE_SPACE RBRACE
RBRACE
``` 

</td>
</tr>
</table>

Tokens have the range information attached, so they can be associated with the text they are pointing to. The tokens are later used for parsing, as navigating tokens is much easier than strings directly.

### Parsing

During this step, parser uses tokens generated by lexer to create a tree representation of the code files (AST - abstract syntax tree). This AST is built from `ASTNode` instances, but majority of compiler doesn't use it directly. 

## Backend

Backend takes this representation and converts it into platform specific code. Each different flavour of Kotlin has its own backend responsible for code generation from IR:

- Kotlin/JVM uses ObjectWeb ASM to generate bytecode directly;
- Kotlin/JS uses custom AST which represents JS code;
- Kotlin/Native lowers its IR into LLVM IR and uses LLVM to provide platform specific assembly.

Before IR is ready to be transformed into platform code, compiler applies a number of lowerings on the backend, making Kotlin IR more similar to the code expected by the platform. The shape of IR before and after transformation is drastically different, initially very similar to the code you have written, but way more platform specific after compiler has finished its lowerings.